\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& User Authentication Module \\
& Code Upload Module \\
& Results Upload Module \\
& Threshold Adjustment Module \\
& Abstract ML Model Module \\
& Tokenization Module \\
& AST Module \\
& Embedded Module \\
& Report Generation Module \\
& Email Sending Module \\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& NLP Model Module \\
& Similarity Scoring Module \\
& Report Results Module \\
& Flagging Module \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

% \section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
%   cross-referencing}

% \wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

% \wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

% \subsection{Module}

% \wss{Short name for the module}

% \subsection{Uses}


% \subsection{Syntax}

% \subsubsection{Exported Constants}

% \subsubsection{Exported Access Programs}

% \begin{center}
% \begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
% \hline
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \hline
% \wss{accessProg} & - & - & - \\
% \hline
% \end{tabular}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}

% \wss{Not all modules will have state variables.  State variables give the module
%   a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture
%   when the module has external interaction with the environment, such as for a
%   device driver, screen interface, keyboard, file, etc.}

% \subsubsection{Assumptions}

% \wss{Try to minimize assumptions and anticipate programmer errors via
%   exceptions, but for practical purposes assumptions are sometimes appropriate.}

% \subsubsection{Access Routine Semantics}

% \noindent \wss{accessProg}():
% \begin{itemize}
% \item transition: \wss{if appropriate} 
% \item output: \wss{if appropriate} 
% \item exception: \wss{if appropriate} 
% \end{itemize}

% \wss{A module without environment variables or state variables is unlikely to
%   have a state transition.  In this case a state transition can only occur if
%   the module is changing the state of another module.}

% \wss{Modules rarely have both a transition and an output.  In most cases you
%   will have one or the other.}

% \subsubsection{Local Functions}

% \wss{As appropriate} \wss{These functions are for the purpose of specification.
%   They are not necessarily something that is going to be implemented
%   explicitly.  Even if they are implemented, they are not exported; they only
%   have local scope.}
\section{MIS of User Authorization Module} \label{AuthModule}

This module provides functionality for user account creation, user login, and
access control, relying on \textbf{Auth0} as the implementation mechanism. It
safeguards the application’s \textbf{secrets} (credentials, tokens, etc.) and
handles authentication and authorization \textbf{services}.

\subsection{Module}

\texttt{AuthModule}

\subsection{Uses}

\begin{itemize}
    \item Auth0 library (for handling OAuth/OpenID Connect flows, token verification, etc.)
    \item Internal user database or identity provider (as configured in Auth0)
    \item Configuration for secrets management (e.g., environment variables or secure vault)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{Module}: Export of the AuthModule React component.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{loginWithRedirect} & - & AuthToken & LoginError \\
\texttt{logout} & - & - & LogoutError \\
\texttt{signup} & - & AuthToken & SignupError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{isAuthenticated}: Boolean indicating whether the user is currently logged in.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{AUTH0\_CLIENT\_ID}: The client identifier for the Auth0 application.
  \item \texttt{AUTH0\_DOMAIN}: The domain used by Auth0 for authentication requests.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The Auth0 services are available and correctly configured (i.e., valid Client ID, Domain, and Client Secret).
    \item Network connectivity is available to communicate with Auth0 endpoints.
    \item User credentials conform to the expected format (valid email, password policy).
    \item The developer using this module has handled any necessary front-end redirection or session cookies for web-based flows.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{loginWithRedirect}():
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Validates user credentials with Auth0.
        \item \texttt{currentSession} is updated with returned AuthToken and user info on success.
    \end{itemize}
    \item \textbf{output:} Returns an \texttt{AuthToken} containing user claims.
    \item \textbf{exception:} \texttt{LoginError} if credentials are invalid or Auth0 is unreachable.
\end{itemize}

\noindent \texttt{logout}(AuthToken):
\begin{itemize}
    \item \textbf{transition:} Invalidates \texttt{currentSession} (or the provided token) by revoking the Auth0 session or clearing local storage.
    \item \textbf{output:} None.
    \item \textbf{exception:} \texttt{LogoutError} if the token is invalid or an Auth0 error occurs.
\end{itemize}

\noindent \texttt{signup}(userInfo):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Redirect user to Auth0 for account creation.
        \item On success, \texttt{currentSession} is redirected back to SyntaxSentienals and updated with new user’s AuthToken.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{AuthToken} for the newly created user.
    \item \textbf{exception:} \texttt{SignupError} if account creation fails (e.g., email already in use).
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.

\section{MIS of Code Upload Module} \label{mCodeUpload}

\subsection{Module}

\texttt{CodeUploadModule}

\begin{description}
    \item[Secrets:] The format and transport of the input data for the model.
    \item[Services:] Converts the input data files into the data structure
    used by the NLP model module and passes it to the backend.
    \item[Implemented By:] \progname{}
    \item[Type of Module:] Library Component
\end{description}

\subsection{Uses}

\begin{itemize}
    \item File system or equivalent I/O library (for reading and writing local files)
    \item HTTP client or backend connector (for sending data to the backend)
    \item Parser or utility library for code/data formatting, if necessary
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{MAX\_FILE\_LENGTH}: The maximum allowed code lines in a single file for upload.
    \item \texttt{ALLOWED\_FILE\_TYPES}: A list of permissible file extensions (e.g., \texttt{.py, .txt, .zip}).
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{uploadFile} & filePath : String & boolean & FileError \\
\texttt{validateFileFormat} & filePath : String & boolean & FormatError \\
\texttt{convertFileToData} & filePath : String & DataStruct & ConversionError \\
\texttt{sendDataToBackend} & data : DataStruct & boolean & BackendError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\begin{itemize}
    \item \texttt{uploadedFile}: Stores the path (or reference) to the currently uploaded file.
    \item \texttt{parsedData}: Stores the in-memory data structure resulting from converting the file.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{TEMP\_UPLOAD\_PATH}: Directory path for temporarily storing uploaded files.
    \item \texttt{BACKEND\_URL}: URL endpoint for sending processed data to the backend.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The file path provided exists and points to a valid file.
    \item Sufficient storage space is available in \texttt{TEMP\_UPLOAD\_PATH}.
    \item The backend service is reachable under \texttt{BACKEND\_URL}.
    \item Uploaded files comply with any project-specific format or version constraints.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{uploadFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:} 
    \begin{itemize}
        \item Copy the file from \textit{filePath} to \texttt{TEMP\_UPLOAD\_PATH}.
        \item Update \texttt{uploadedFile} to reflect the new file location.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{true} on success.
    \item \textbf{exception:} \texttt{FileError} if file I/O fails or \textit{filePath} is invalid.
\end{itemize}

\noindent \texttt{validateFileFormat}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:} None (no internal state change).
    \item \textbf{output:} Returns \texttt{true} if the file meets \texttt{MAX\_FILE\_SIZE} and 
    \texttt{ALLOWED\_FILE\_TYPES} conditions.
    \item \textbf{exception:} \texttt{FormatError} if the file type or size is invalid.
\end{itemize}

\noindent \texttt{convertFileToData}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Reads raw file content from the \texttt{uploadedFile}.
        \item Parses and converts the content into \texttt{parsedData}.
    \end{itemize}
    \item \textbf{output:} A \texttt{DataStruct} representing the file’s contents.
    \item \textbf{exception:} \texttt{ConversionError} if file parsing fails or content is malformed.
\end{itemize}

\noindent \texttt{sendDataToBackend}(\textit{data}):
\begin{itemize}
    \item \textbf{transition:} None (communicates externally, no internal state change).
    \item \textbf{output:} \texttt{true} if the backend confirms successful data receipt.
    \item \textbf{exception:} \texttt{BackendError} if backend is unreachable or fails to accept data.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readLocalFile(path)}: Internal function for raw file I/O.
    \item \texttt{parseCodeData(rawContent)}: Transforms raw file content into a \texttt{DataStruct}.
\end{itemize}

\section{MIS of Results Upload Module} \label{mResultsUpload}

\subsection{Module}

\texttt{ResultsUploadModule}

\subsection{Uses}

\begin{itemize}
    \item File system or equivalent I/O utilities (to read and load local report files, if applicable)
    \item Front-end/UI framework (to display the parsed results)
    \item HTTP or backend connector (if the parsed results need to be sent elsewhere)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{MAX\_REPORT\_FILE\_SIZE}: Maximum allowed file size (in bytes) for a report file.
    \item \texttt{ALLOWED\_REPORT\_TYPES}: Only .zip is allowed.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{uploadResultsFile} & filePath : String & boolean & FileError \\
\texttt{parseResultsFile} & filePath : String & ResultsDataStruct & ParseError \\
\texttt{displayResults} & data : ResultsDataStruct, uiTarget : UIContainer & boolean & DisplayError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{uploadedReportFile}: Stores the path (or reference) to the currently uploaded report file.
    \item \texttt{parsedReportData}: Stores the in-memory data structure resulting from parsing the report file.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{TEMP\_REPORT\_PATH}: Directory path for temporarily storing uploaded report files.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The file path provided points to a valid file and does not exceed \texttt{MAX\_REPORT\_FILE\_SIZE}.
    \item The file type is one of \texttt{ALLOWED\_REPORT\_TYPES}.
    \item The front-end/UI framework is loaded and available for rendering the report data.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{uploadResultsFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Copies file from \textit{filePath} to \texttt{TEMP\_REPORT\_PATH} (if needed).
        \item Updates \texttt{uploadedReportFile} to reflect the new file location.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{true} if upload is successful.
    \item \textbf{exception:} \texttt{FileError} if reading or copying the file fails.
\end{itemize}

\noindent \texttt{parseResultsFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Opens and reads the specified report file.
        \item Creates an in-memory \texttt{ResultsDataStruct} (\texttt{parsedReportData}) from the file content.
    \end{itemize}
    \item \textbf{output:} A \texttt{ResultsDataStruct} representing the parsed report data.
    \item \textbf{exception:} \texttt{ParseError} if the file format is invalid or parsing fails.
\end{itemize}

\noindent \texttt{displayResults}(\textit{data, uiTarget}):
\begin{itemize}
    \item \textbf{transition:} None (no change to internal state).
    \item \textbf{output:} Returns \texttt{true} if the report data is successfully rendered in the specified UI container.
    \item \textbf{exception:} \texttt{DisplayError} if rendering or updating the UI fails.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readLocalReportFile(filePath)}: Handles raw file I/O for reading report files.
    \item \texttt{parseReportContent(rawContent)}: Transforms the raw file content into a \texttt{ResultsDataStruct}.
    \item \texttt{renderReport(data, container)}: UI logic to display \texttt{ResultsDataStruct} in a given front-end container.
\end{itemize}

\section{MIS of Threshold Adjustment Module} \label{mThreshold}


\subsection{Module}

\texttt{ThresholdAdjustmentModule}

\subsection{Uses}

\begin{itemize}
    \item A back-end or configuration service (to store and retrieve the threshold settings)
    \item A front-end/UI component (the actual slider element the user interacts with)
    \item Possibly a validation or range-check module (to ensure threshold inputs are within acceptable bounds)
\end{itemize}

\subsection{Syntax}

\subsubsection{User-Defined Data Types}

\begin{itemize}
    \item \textbf{\texttt{ThresholdValue}}: A numeric type (e.g., \texttt{float} in $[0,1]$ or \texttt{int} in $[0,100]$) that the slider can represent.
    \item \textbf{\texttt{ThresholdRange}}: A structure or pair \texttt{(minValue, maxValue)} denoting the allowable slider bounds.
    \item \textbf{\texttt{Boolean}}: A logical type that can be either \texttt{true} or \texttt{false}.
    \item \textbf{\texttt{ExceptionType}}: A generic exception category (e.g., \texttt{ThresholdError}).
\end{itemize}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{DEFAULT\_THRESHOLD} : \texttt{ThresholdValue} (e.g., 0.75) used if no custom threshold is set.
    \item \texttt{THRESHOLD\_RANGE} : \texttt{ThresholdRange} (e.g., \texttt{(0, 1)}) defining the slider’s permissible bounds.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{3.8cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{getThreshold} 
  & - 
  & \texttt{ThresholdValue} 
  & \texttt{ThresholdError} \\

\texttt{setThreshold} 
  & \textit{newVal : ThresholdValue}
  & \texttt{Boolean}
  & \texttt{ThresholdError} \\

\texttt{validateThreshold} 
  & \textit{value : ThresholdValue}
  & \texttt{Boolean} 
  & \texttt{ThresholdError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{currentThreshold} : \texttt{ThresholdValue} \\
    Represents the current position of the slider, reflecting the chosen plagiarism detection threshold.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{THRESHOLD\_CONFIG\_ENDPOINT} : \texttt{String} \\
    The network endpoint or file resource where the threshold configuration is stored/persisted.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item \texttt{currentThreshold} is always within \texttt{THRESHOLD\_RANGE}.
    \item The user moves the slider to pick a threshold within valid bounds.
    \item Any saved or loaded threshold configurations adhere to the same data format as defined here.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{getThreshold}():
\begin{itemize}
    \item \textbf{transition:} None (no change to internal state).
    \item \textbf{output:} Returns the current threshold (slider position), \texttt{currentThreshold}.
    \item \textbf{exception:} \texttt{ThresholdError} if the threshold is undefined or fails to load from persistence.
\end{itemize}

\noindent \texttt{setThreshold}(\textit{newVal}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Uses \texttt{validateThreshold} to check if \textit{newVal} falls within \texttt{THRESHOLD\_RANGE}.
        \item Updates \texttt{currentThreshold} to \textit{newVal} if valid.
        \item Saves the new value to the configuration endpoint or local store.
    \end{itemize}
    \item \textbf{output:} \texttt{true} if \textit{newVal} is successfully set; otherwise \texttt{false}.
    \item \textbf{exception:} \texttt{ThresholdError} if \textit{newVal} is out of range or otherwise invalid.
\end{itemize}

\noindent \texttt{validateThreshold}(\textit{value}):
\begin{itemize}
    \item \textbf{transition:} None (does not change internal state).
    \item \textbf{output:} \texttt{true} if \textit{value} is in \texttt{THRESHOLD\_RANGE}; otherwise \texttt{false}.
    \item \textbf{exception:} \texttt{ThresholdError} if \textit{value} is malformed (e.g., not a number).
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readCurrentThreshold()} : Internal function to read the stored threshold from \texttt{THRESHOLD\_CONFIG\_ENDPOINT}.
    \item \texttt{writeCurrentThreshold(value : ThresholdValue)} : Internal function to persist \textit{value} at \texttt{THRESHOLD\_CONFIG\_ENDPOINT}.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}