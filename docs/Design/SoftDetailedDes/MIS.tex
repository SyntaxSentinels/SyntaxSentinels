\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
January 17 & 1.0 & Initial documentation\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \href{https://github.com/SyntaxSentinels/SyntaxSentinels/blob/main/docs/SRS-Volere/SRS.pdf}{SRS}

% \wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for SyntaxSentinals.

This project seeks to create a plagiarism algorithm that relies on NLP
techniques of present to account for semantics and prevent primitive cir-
cumvention of plagiarism detection, such as the addition of benign lines or
variable name changes. The users of our product will primarily be those con-
cerned with fairness and integrity of code submissions within a competitive
environment, such as professors or code competition holders.

Users are intended to use the resulting product of our project by giving
it code snippets and receiving a plagiarism report in return. This report
will contain a set of similarity scores for inputted code snippets, which when
assessed against an outputted threshold will indicate likelihood of plagiarsm
having taken place. This will benefit the users by allowing them to more accurately assess the presence of plagiarized work, 
creating a fairer environment for competition and rewarding coders correctly. 
Ultimately, the project aims to help users achieve an environment that cycles merit 
instead of cheating, which is believed to be a primary interest of users too.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/SyntaxSentinels/SyntaxSentinels}. 

\section{Notation}

Below is a summary of the notations used in this document:

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent
\begin{tabular}{l l p{8cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\ 
\midrule
character & char & A single symbol or digit. \\ 
integer & $\mathbb{Z}$ & A whole number in the range $(-\infty, \infty)$. \\ 
natural number & $\mathbb{N}$ & A whole number in the range $[1, \infty)$. \\ 
real & $\mathbb{R}$ & Any number in the range $(-\infty, \infty)$. \\ 
boolean & bool & A logical value that can either be \texttt{true} or \texttt{false}. \\
string & str & A sequence of characters. \\ 
tuple & tuple & An ordered collection of elements, potentially of different types. \\ 
\bottomrule 
\end{tabular} 
\end{center}

\noindent
The following conventions are also used:
\begin{itemize}
    \item \textbf{Assignment}: The operator \texttt{:=} denotes assignment.
    \item \textbf{Conditional Rules}: Conditional statements follow the structure $(c_1 \Rightarrow r_1 \mid c_2 \Rightarrow r_2 \mid \ldots \mid c_n \Rightarrow r_n)$, where $c_i$ are conditions and $r_i$ are corresponding results.
    \item \textbf{Access Programs}: Functions and methods are defined with their inputs, outputs, and exceptions as described in the syntax sections of each module.
\end{itemize}

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
    \centering
    \begin{tabular}{p{0.35\textwidth} p{0.55\textwidth}}
    \toprule
    \textbf{Level 1} & \textbf{Level 2} \\
    \midrule
    {Hardware-Hiding Module} & ~ \\
    \midrule
    \multirow{2}{*}{Behaviour-Hiding Module} 
    & User Authentication Module \\
    & Code Upload Module \\
    & Results Upload Module \\
    & Report Results Module \\
    & Email Sending Module \\
    & Flagging Module \\
    & Threshold Adjustment Module \\
    \midrule
    \multirow{2}{*}{Software Decision Module} 
    & Report Generation Module \\
    & Similarity Scoring Module \\
    & NLP Model Module \\
    & Abstract ML Model Module \\
    & Tokenization Module \\
    & AST Module \\
   
    \bottomrule
    \end{tabular}
    \caption{Module Hierarchy}
    \label{TblMH}
  \end{table}
%new breakdown
\newpage
~\newpage

% \section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
%   cross-referencing}

% \wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

% \wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

% \subsection{Module}

% \wss{Short name for the module}

% \subsection{Uses}


% \subsection{Syntax}

% \subsubsection{Exported Constants}

% \subsubsection{Exported Access Programs}

% \begin{center}
% \begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
% \hline
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \hline
% \wss{accessProg} & - & - & - \\
% \hline
% \end{tabular}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}

% \wss{Not all modules will have state variables.  State variables give the module
%   a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture
%   when the module has external interaction with the environment, such as for a
%   device driver, screen interface, keyboard, file, etc.}

% \subsubsection{Assumptions}

% \wss{Try to minimize assumptions and anticipate programmer errors via
%   exceptions, but for practical purposes assumptions are sometimes appropriate.}

% \subsubsection{Access Routine Semantics}

% \noindent \wss{accessProg}():
% \begin{itemize}
% \item transition: \wss{if appropriate} 
% \item output: \wss{if appropriate} 
% \item exception: \wss{if appropriate} 
% \end{itemize}

% \wss{A module without environment variables or state variables is unlikely to
%   have a state transition.  In this case a state transition can only occur if
%   the module is changing the state of another module.}

% \wss{Modules rarely have both a transition and an output.  In most cases you
%   will have one or the other.}

% \subsubsection{Local Functions}

% \wss{As appropriate} \wss{These functions are for the purpose of specification.
%   They are not necessarily something that is going to be implemented
%   explicitly.  Even if they are implemented, they are not exported; they only
%   have local scope.}

\section{MIS of User Authentication Module} \label{AuthModule}

This module provides functionality for user account creation, user login, and
access control, relying on \textbf{Auth0} as the implementation mechanism. It
safeguards the application's \textbf{secrets} (credentials, tokens, etc.) and
handles authentication and authorization \textbf{services}.


\subsection{Module}

\texttt{AuthModule}

\subsection{Uses}

\begin{itemize}
    \item Auth0 library (for handling OAuth/OpenID Connect flows, token verification, etc.)
    \item Internal user database or identity provider (as configured in Auth0)
    \item Configuration for secrets management (e.g., environment variables or secure vault)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{Module}: Export of the AuthModule React component.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{loginWithRedirect} & - & AuthToken & LoginError \\
\texttt{logout} & - & - & LogoutError \\
\texttt{signup} & - & AuthToken & SignupError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{isAuthenticated}: Boolean indicating whether the user is currently logged in.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{AUTH0\_CLIENT\_ID}: The client identifier for the Auth0 application.
  \item \texttt{AUTH0\_DOMAIN}: The domain used by Auth0 for authentication requests.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The Auth0 services are available and correctly configured (i.e., valid Client ID, Domain, and Client Secret).
    \item Network connectivity is available to communicate with Auth0 endpoints.
    \item User credentials conform to the expected format (valid email, password policy).
    \item The developer using this module has handled any necessary front-end redirection or session cookies for web-based flows.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{loginWithRedirect}():
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Validates user credentials with Auth0.
        \item \texttt{currentSession} is updated with returned AuthToken and user info on success.
    \end{itemize}
    \item \textbf{output:} Returns an \texttt{AuthToken} containing user claims.
    \item \textbf{exception:} \texttt{LoginError} if credentials are invalid or Auth0 is unreachable.
\end{itemize}

\noindent \texttt{logout}(AuthToken):
\begin{itemize}
    \item \textbf{transition:} Invalidates \texttt{currentSession} (or the provided token) by revoking the Auth0 session or clearing local storage.
    \item \textbf{output:} None.
    \item \textbf{exception:} \texttt{LogoutError} if the token is invalid or an Auth0 error occurs.
\end{itemize}

\noindent \texttt{signup}(userInfo):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Redirect user to Auth0 for account creation.
        \item On success, \texttt{currentSession} is redirected back to SyntaxSentienals and updated with new user’s AuthToken.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{AuthToken} for the newly created user.
    \item \textbf{exception:} \texttt{SignupError} if account creation fails (e.g., email already in use).
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.

\section{MIS of Code Upload Module} \label{mCodeUpload}

\subsection{Module}

\texttt{CodeUploadModule}

\begin{description}
    \item[Secrets:] The format and transport of the input data for the model.
    \item[Services:] Converts the input data files into the data structure
    used by the NLP model module and passes it to the backend.
    \item[Implemented By:] \progname{}
    \item[Type of Module:] Library Component
\end{description}

\subsection{Uses}

\begin{itemize}
    \item File system or equivalent I/O library (for reading and writing local files)
    \item HTTP client or backend connector (for sending data to the backend)
    \item Parser or utility library for code/data formatting, if necessary
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{MAX\_FILE\_LENGTH}: The maximum allowed code lines in a single file for upload.
    \item \texttt{ALLOWED\_FILE\_TYPES}: A list of permissible file extensions (e.g., \texttt{.py, .txt, .zip}).
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{uploadFile} & filePath : String & boolean & FileError \\
\texttt{validateFileFormat} & filePath : String & boolean & FormatError \\
\texttt{convertFileToData} & filePath : String & DataStruct & ConversionError \\
\texttt{sendDataToBackend} & data : DataStruct & boolean & BackendError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\begin{itemize}
    \item \texttt{uploadedFile}: Stores the path (or reference) to the currently uploaded file.
    \item \texttt{parsedData}: Stores the in-memory data structure resulting from converting the file.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{TEMP\_UPLOAD\_PATH}: Directory path for temporarily storing uploaded files.
    \item \texttt{BACKEND\_URL}: URL endpoint for sending processed data to the backend.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The file path provided exists and points to a valid file.
    \item Sufficient storage space is available in \texttt{TEMP\_UPLOAD\_PATH}.
    \item The backend service is reachable under \texttt{BACKEND\_URL}.
    \item Uploaded files comply with any project-specific format or version constraints.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{uploadFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:} 
    \begin{itemize}
        \item Copy the file from \textit{filePath} to \texttt{TEMP\_UPLOAD\_PATH}.
        \item Update \texttt{uploadedFile} to reflect the new file location.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{true} on success.
    \item \textbf{exception:} \texttt{FileError} if file I/O fails or \textit{filePath} is invalid.
\end{itemize}

\noindent \texttt{validateFileFormat}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:} None (no internal state change).
    \item \textbf{output:} Returns \texttt{true} if the file meets \texttt{MAX\_FILE\_SIZE} and 
    \texttt{ALLOWED\_FILE\_TYPES} conditions.
    \item \textbf{exception:} \texttt{FormatError} if the file type or size is invalid.
\end{itemize}

\noindent \texttt{convertFileToData}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Reads raw file content from the \texttt{uploadedFile}.
        \item Parses and converts the content into \texttt{parsedData}.
    \end{itemize}
    \item \textbf{output:} A \texttt{DataStruct} representing the file's contents.
    \item \textbf{exception:} \texttt{ConversionError} if file parsing fails or content is malformed.
\end{itemize}

\noindent \texttt{sendDataToBackend}(\textit{data}):
\begin{itemize}
    \item \textbf{transition:} None (communicates externally, no internal state change).
    \item \textbf{output:} \texttt{true} if the backend confirms successful data receipt.
    \item \textbf{exception:} \texttt{BackendError} if backend is unreachable or fails to accept data.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readLocalFile(path)}: Internal function for raw file I/O.
    \item \texttt{parseCodeData(rawContent)}: Transforms raw file content into a \texttt{DataStruct}.
\end{itemize}

\section{MIS of Results Upload Module} \label{mResultsUpload}

\subsection{Module}

\texttt{ResultsUploadModule}

\subsection{Uses}

\begin{itemize}
    \item File system or equivalent I/O utilities (to read and load local report files, if applicable)
    \item Front-end/UI framework (to display the parsed results)
    \item HTTP or backend connector (if the parsed results need to be sent elsewhere)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{MAX\_REPORT\_FILE\_SIZE}: Maximum allowed file size (in bytes) for a report file.
    \item \texttt{ALLOWED\_REPORT\_TYPES}: Only .zip is allowed.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{uploadResultsFile} & filePath: String & boolean & FileError \\
\texttt{parseResultsFile} & filePath: String & ReportDataStruct & ParseError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{uploadedReportFile}: Stores the path (or reference) to the currently uploaded report file.
    \item \texttt{parsedReportData}: Stores the in-memory data structure resulting from parsing the report file.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The file path provided points to a valid file and does not exceed \texttt{MAX\_REPORT\_FILE\_SIZE}.
    \item The file type is one of \texttt{ALLOWED\_REPORT\_TYPES}.
    \item The front-end/UI framework is loaded and available for rendering the report data.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{uploadResultsFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Copies file from \textit{filePath} to \texttt{TEMP\_REPORT\_PATH} (if needed).
        \item Updates \texttt{uploadedReportFile} to reflect the new file location.
    \end{itemize}
    \item \textbf{output:} Returns \texttt{true} if upload is successful.
    \item \textbf{exception:} \texttt{FileError} if reading or copying the file fails.
\end{itemize}

\noindent \texttt{parseResultsFile}(\textit{filePath}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Opens and reads the specified report file.
        \item Creates an in-memory \texttt{ReportDataStruct} (\texttt{parsedReportData}) from the file content.
    \end{itemize}
    \item \textbf{output:} A \texttt{ReportDataStruct} representing the parsed report data.
    \item \textbf{exception:} \texttt{ParseError} if the file format is invalid or parsing fails.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readLocalReportFile(filePath)}: Handles raw file I/O for reading report files.
    \item \texttt{parseReportContent(rawContent)}: Transforms the raw file content into a \texttt{ReportDataStruct}.
\end{itemize}

\section{MIS of Threshold Adjustment Module} \label{mThreshold}


\subsection{Module}

\texttt{ThresholdAdjustmentModule}

\subsection{Uses}

\begin{itemize}
    \item A back-end or configuration service (to store and retrieve the threshold settings)
    \item A front-end/UI component (the actual slider element the user interacts with)
    \item Possibly a validation or range-check module (to ensure threshold inputs are within acceptable bounds)
\end{itemize}

\subsection{Syntax}

\subsubsection{User-Defined Data Types}

\begin{itemize}
    \item \textbf{\texttt{ThresholdValue}}: A numeric type (e.g., \texttt{float} in $[0,1]$ or \texttt{int} in $[0,100]$) that the slider can represent.
    \item \textbf{\texttt{ThresholdRange}}: A structure or pair \texttt{(minValue, maxValue)} denoting the allowable slider bounds.
    \item \textbf{\texttt{Boolean}}: A logical type that can be either \texttt{true} or \texttt{false}.
    \item \textbf{\texttt{ExceptionType}}: A generic exception category (e.g., \texttt{ThresholdError}).
\end{itemize}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \texttt{DEFAULT\_THRESHOLD} : \texttt{ThresholdValue} (e.g., 0.75) used if no custom threshold is set.
    \item \texttt{THRESHOLD\_RANGE} : \texttt{ThresholdRange} (e.g., \texttt{(0, 1)}) defining the slider’s permissible bounds.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.5cm} p{3.8cm} p{3cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{getThreshold} 
  & - 
  & \texttt{ThresholdValue} 
  & \texttt{ThresholdError} \\

\texttt{setThreshold} 
  & \textit{newVal : ThresholdValue}
  & \texttt{Boolean}
  & \texttt{ThresholdError} \\

\texttt{validateThreshold} 
  & \textit{value : ThresholdValue}
  & \texttt{Boolean} 
  & \texttt{ThresholdError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{currentThreshold} : \texttt{ThresholdValue} \\
    Represents the current position of the slider, reflecting the chosen plagiarism detection threshold.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{THRESHOLD\_CONFIG\_ENDPOINT} : \texttt{String} \\
    The network endpoint or file resource where the threshold configuration is stored/persisted.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item \texttt{currentThreshold} is always within \texttt{THRESHOLD\_RANGE}.
    \item The user moves the slider to pick a threshold within valid bounds.
    \item Any saved or loaded threshold configurations adhere to the same data format as defined here.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{getThreshold}():
\begin{itemize}
    \item \textbf{transition:} None (no change to internal state).
    \item \textbf{output:} Returns the current threshold (slider position), \texttt{currentThreshold}.
    \item \textbf{exception:} \texttt{ThresholdError} if the threshold is undefined or fails to load from persistence.
\end{itemize}

\noindent \texttt{setThreshold}(\textit{newVal}):
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item Uses \texttt{validateThreshold} to check if \textit{newVal} falls within \texttt{THRESHOLD\_RANGE}.
        \item Updates \texttt{currentThreshold} to \textit{newVal} if valid.
        \item Saves the new value to the configuration endpoint or local store.
    \end{itemize}
    \item \textbf{output:} \texttt{true} if \textit{newVal} is successfully set; otherwise \texttt{false}.
    \item \textbf{exception:} \texttt{ThresholdError} if \textit{newVal} is out of range or otherwise invalid.
\end{itemize}

\noindent \texttt{validateThreshold}(\textit{value}):
\begin{itemize}
    \item \textbf{transition:} None (does not change internal state).
    \item \textbf{output:} \texttt{true} if \textit{value} is in \texttt{THRESHOLD\_RANGE}; otherwise \texttt{false}.
    \item \textbf{exception:} \texttt{ThresholdError} if \textit{value} is malformed (e.g., not a number).
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{readCurrentThreshold()} : Internal function to read the stored threshold from \texttt{THRESHOLD\_CONFIG\_ENDPOINT}.
    \item \texttt{writeCurrentThreshold(value : ThresholdValue)} : Internal function to persist \textit{value} at \texttt{THRESHOLD\_CONFIG\_ENDPOINT}.
\end{itemize}


\section{MIS of Flagging Module} \label{FlagModule}

\subsection{Module}

\texttt{FlagModule}

\subsection{Uses}

\begin{itemize}
    \item Front-end/UI framework for displaying flagged items.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{getFlaggedStatus} & submissionID: string & boolean & - \\
\texttt{setFlaggedStatus} & submissionID: string, flag: boolean & - & - \\
\texttt{getAllFlagged} & - & list[string] & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{flaggedSubmissions}: A list of flagged submissions.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{getFlaggedStatus(submissionID: string)}:
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{input:} The unique \texttt{submissionID} for which the flagged status is queried
    \item \textbf{output:} Returns the flagged status (\texttt{true} or \texttt{false}) for the given \texttt{submissionID}
\end{itemize}

\noindent \texttt{setFlaggedStatus(submissionID: string, flag: boolean)}:
\begin{itemize}
    \item \textbf{transition:} Updates the flagged status of the specified \texttt{submissionID} to the provided \texttt{flag} value
    \item \textbf{input:} 
    \begin{itemize}
        \item \texttt{submissionID}: The unique identifier of the submission to update
        \item \texttt{flag}: A boolean value indicating the new flagged status (\texttt{true} or \texttt{false})
    \end{itemize}
    \item \textbf{output:} None.
\end{itemize}

\noindent \texttt{getAllFlagged()}:
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{input:} None
    \item \textbf{output:} Returns a list of all \texttt{submissionID}s that are currently flagged
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.
% END OF FLAGGING


\section{MIS of Report Results Module} \label{ResultsModule}

\subsection{Module}

\texttt{ResultsModule}

\subsection{Uses}

\begin{itemize}
    \item Frontend for rendering reports visually for users
    \item \texttt{ReportDataStruct} from Results Upload Module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Program}

\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{renderReport} & report: ReportDataStruct & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{reports}: A list of reports to be displayed
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderReport(reports: ReportDataStruct)}:
\begin{itemize}
    \item \textbf{input:} The report data (\texttt{ReportDataStruct}) of the report to be rendered
    \item \textbf{transition:} None
    \item \textbf{output:} Renders a visual representation of the report in the browser
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.

%END OF REPORT RESULTS MODULE

\subsection{NLP Module}  \label{NLPModule}

\texttt{NLPModule}

\subsection{Uses}

\begin{itemize}
    \item Abstract ML Model Module
    \item Tokenization Module
    \item AST Module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{combinedPredict} & data: DataStruct & relations: combinedPrediction & -\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The input code within DataStruct is in one programming language.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \texttt{combinedPredict}(data: DataStruct):
\begin{itemize}
    \item \textbf{transition: None} 
    \item \textbf{output: relations: combinedPrediction} an assembly of results 
    from each of the used modules is combined to get a more balanced perspective 
    \item \textbf{exception: None}
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.


%END OF NLP Module

\section{MIS of Abstract Model Module} \label{AbModelModule}

\subsection{Module}

\texttt{AbModelModule}

\subsection{Uses}

\begin{itemize}
    \item \texttt{transformers} library
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{train} & data: DataStruct, timeout: integer & None & TimeOutException \\
\texttt{predict} & data: DataStruct & result: Prediction & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item weightings
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The input code within DataStruct is in one programming language.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \texttt{train(data: DataStruct, timeout: integer)}:
\begin{itemize}
    \item \textbf{transition:} weightings := updated\_weightings -- assign new weightings from batch training to weightings
    \item \textbf{output:} None
    \item \textbf{exception:} \texttt{TimeOutException} if training time exceeds time limit allotted. 
\end{itemize}

\noindent \texttt{predict(data: DataStruct)}:
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{output:} Prediction object containing semantic relations between code snippets contained within the DataStruct data.
    \item \textbf{exception:} None
\end{itemize}
% END OF ABSTRACT MODEL MODULE


\section{MIS of Tokenization Modlue} \label{TokModule}

\subsection{Module}

\texttt{TokModule}

\subsection{Uses}

\begin{itemize}
    \item None
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{tokenize} & DataStruct & list[Token] & TokenizeError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The input code within DataStruct is in one programming language.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{tokenize(source: string)}:
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item None
    \end{itemize}
    \item \textbf{output:} Returns a list of tokens corresponding to the input source text.
    \item \textbf{exception:} \texttt{TokenizeError} if the source code is syntactically invalid.
\end{itemize}

\subsubsection{Local Functions}

\noindent \texttt{pollOneToken()}:
\begin{itemize}
    \item \textbf{transition:}
    \begin{itemize}
        \item None
    \end{itemize}
    \item \textbf{output:} Returns a single token read from the given index in the source string, or None if invalid.
    % \item \textbf
\end{itemize}
% END OF TOKENIZATION MODULE

\section{MIS of AST Module} \label{ASTModule}

\subsection{Module}

\texttt{ASTModule}

\subsection{Uses}

\begin{itemize}
    \item Built in (for python) or external tokenizer and tree parsers
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{parse} & rawSource: string & ASTNode & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{Assumptions}

\begin{itemize}
    \item The expression provided to \texttt{parse} is syntactically correct or can be parsed with the given rules.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{parse(rawSource)}:
\begin{itemize}
    \item \textbf{input:} A string representing the input source code
    \item \textbf{transition:} None
    \item \textbf{output:} Returns the root node of the AST, or None if the input was invalid
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.
% END OF AST MODULE

\subsection{Similarity Scoring Module}

\texttt{SimScoreModule}

\subsection{Uses}

\begin{itemize}
    \item NLP module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{score} & data: DataStruct & scores: Map[2-tuple[str]: list[Real]] & - \\ %mathematical notation here, specify n choose 2 scores
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The input code within DataStruct is in one programming language.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \texttt{score}(data: DataStruct):
\begin{itemize}
    \item \textbf{transition: None} 
    \item \textbf{output: Map[2-tuple[str]: list[Real]]} \# denote this more mathematically?
    \item \textbf{exception: None}
\end{itemize}

\subsubsection{Local Functions}
No local functions are required for this module.


%END OF SIMILARITY SCORING MODULE

\subsection{Report Generation Module}

\texttt{RepGenModule}

\subsection{Uses}

\begin{itemize}
    \item Similarity Scoring Module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{generate} & data: DataStruct & report: ReportDataStruct & -\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item None
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item The input code within DataStruct is in one programming language.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \texttt{generate}(data: DataStruct):
\begin{itemize}
    \item \textbf{transition: None} 
    \item \textbf{output: ReportDataStruct} object wrapping visuals associated with report and 
    similarity scorings to be received by the front end
    \item \textbf{exception: None}
\end{itemize}

\subsubsection{Local Functions}
 \noindent \texttt{assembleVisuals}(data: DataStruct):
\begin{itemize}
    \item \textbf{transition: None} 
    \item \textbf{output:JSON} 
    \item \textbf{exception: None}
\end{itemize}


%END OF REPORT GENERATION MODULE

\section{MIS of Email Sending Module} \label{EmailModule}

\subsection{Module}

\texttt{EmailModule}

\subsection{Uses}

\begin{itemize}
    \item SMTP server or email-sending service (such as SendGrid or Amazon SES)
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{5cm} p{3.5cm} p{3.5cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{sendEmail} & recipient: string, subject: string, body: string, attachments: list[file] & boolean & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item None
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item \texttt{SMTP\_CONFIG}: Configuration details for connecting to the SMTP server (e.g., host, port, authentication).
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item A SMTP server or email-sending service is available and configured correctly
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{sendEmail(recipient: string, subject: string, \\
    body: string, attachments: list[file])}:
\begin{itemize}
    \item \textbf{input:} 
    \begin{itemize}
        \item \texttt{recipient}: Email address of the primary recipient
        \item \texttt{subject}: Subject of the email
        \item \texttt{body}: The main body content of the email (plain text or HTML)
        \item \texttt{attachments}: A list of file objects to be attached to the email
    \end{itemize}
    \item \textbf{transition:} None
    \item \textbf{output:} Returns \texttt{true} if the email is sent successfully; otherwise, throws \texttt{EmailSendException}.
\end{itemize}


\subsubsection{Local Functions}
No local functions are required for this module.
% END OF EMAIL SENDING MODULE

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\newpage{}

\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?}   \\
  The process of writing this deliverable was smooth due to the clear structure and guidelines provided. The team collaborated effectively, leveraging each member's strengths. Additionally, the availability of comprehensive documentation and resources facilitated the writing process.

  \item \textbf{What pain points did you experience during this deliverable, and how did you resolve them?}  \\
  One of the main pain points was ensuring consistency across different sections of the document. To resolve this, we conducted regular team meetings to review progress and align on the content. Another challenge was integrating feedback from various team members, which sometimes led to conflicting requirements. We addressed this by prioritizing feedback based on its impact on the project and seeking clarification when necessary.

  \item \textbf{Which of your design decisions stemmed from speaking to your client(s) or a proxy (e.g., your peers, stakeholders, potential users)? For those that were not, why, and where did they come from?}  \\
  None of our existing documents needed to be changed as they were correct upon review.

  \item \textbf{While creating the design doc, what parts of your other documents (e.g., requirements, hazard analysis, etc.), if any, needed to be changed, and why?}  \\
  During the creation of the design document, we identified the need to update the requirements document to reflect changes in the authentication mechanism. Additionally, the hazard analysis document was revised to include potential security risks associated with external service integrations. These changes were necessary to ensure all documents were aligned and accurately represented the current state of the project.

  \item \textbf{What are the limitations of your solution? Put another way, given unlimited resources, what could you do to make the project better?}  \\
  One limitation of our solution is the reliance on external services, which introduces dependencies and potential points of failure. Given unlimited resources, we could develop in-house solutions for critical services to reduce dependency risks. Additionally, we could invest in more robust testing and monitoring tools to enhance the system's reliability and performance. Expanding the team to include specialists in security and performance optimization would also contribute to a more resilient solution.

  \item \textbf{Give a brief overview of other design solutions you considered. What are the benefits and tradeoffs of those other designs compared with the chosen design? From all the potential options, why did you select the documented design?}  \\
  We considered several design alternatives, including using different authentication providers and data storage solutions. For example, we evaluated Firebase Authentication as an alternative to Auth0. While Firebase offers seamless integration with other Firebase services, Auth0 was chosen for its advanced security features and flexibility.
\end{enumerate}



\end{document}